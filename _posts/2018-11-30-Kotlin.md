---
layout: post
title: 思维
category: Read
tags: [Read]
---


## 1. 2019.07.19 《高效能人士的7个习惯》史蒂芬‧柯维

Kotlin 只读list而不是可变

#### 1 核心

###### 1. 面向对象

	1. 类和构造函数，参数，接口，

   	2. 延迟初始化，主从构造方法
   	3. 限制修饰符
   	4. 多继承 class Bird(override val name: String): Flyer, Animal {}  ， 使用委托代替多继承
   	5. copy， componentN与解构
   	6. 天生的单例 object
   	7. 数据类

###### 2. 代数数据类型和模式匹配

1. 代数数据类型：和类型和积类型
2. 构造代数数据类型：基本类型—枚举类和密封类。类型安全
3. 模式——表达式，常量，类型，逻辑表达式
4. 模式匹配—匹配表达式，when能简化很多问题
5. 实现模式匹配的技术—主要有6种，kotlin中常出现的是3种：类型测试/类型装换、面向对象分解、访问者设计模式。
6. 增强kotlin的模式匹配：5中的3点。
7. 使用代数数据类型来抽象业务：利用ADT思想对事物进行描述，逐步分析。
8. 更高层次的抽象

###### 3. 类型系统

1. null引发的问题
2. 解决null的一些方案—函数对于无效值，可以抛异常处理；采用@NotNull/@Nullable标注；使用专门的Optional对象对可能为null的变量进行装箱。
3. 可空类型
4. kotlin的类型层级
5. 泛型让类型变得更安全  Java中使用<T>
6. 泛型擦除
7. 泛型变形：泛型的协变与逆变。

###### 4. Lambda和集合

1. Lambda简化表达：与Java函数式接口结合，结合可接收类型，集合中的函数式API
2. 集合API，吸取lambda表达式的简洁。
3. 可变集合与只读集合—当kotlin与Java互相操作时，只读集合可能被改变。
4. 惰性集合：也就是序列seq，如果在一般集合上进行链式操作的话，会产生许多中间集合，这会带来不小的开销，此时kotlin引入惰性集合。我们先将集合转化为序列，然后进行相关操作。
5. 中间操作与末端操作—这是序列的两个操作方式。 在对普通集合产生链式操作时，会产生中间集合，当这类操作对序列进行求值就称为中间操作。末端操作是一个返回结果的操作。
6. 内联函数，采用内联函数对Lambda带来的额外开销进行优化。

###### 5. 多态和扩展

1. 多态
2. 特设多态——扩展以及重载是特设多态的一种。符合面向对象设计的基本原则之一——开放封闭原则。
3. 扩展函数——对应的Java的static方法
4. 扩展函数接收器——调度接收器，扩展接收器
5. 正确使用扩展函数

###### 6. 元编程

1. 元编程：运行时期的元编程，编译时期的元编程。
2. 反射——运行时期的元编程，涉及类——KClass，KCallable，KParameter，KFunction，KProperty等。
3. 注解
4. 注解处理器

#### 2 探索

###### 1. 设计模式

1. 改造工厂模式

2. 内联函数简化抽象工厂

3. 弱化构建者模式的使用

4. 用委托属性实现观察者模式

5. 高阶函数简化设计模式

6. 重载iteratior方法

7. 偏函数实现责任链模式

8. ADT实现状态模式

9. 装饰着模式实现新思路

    

###### 2. 函数式编程

1. 函数式语言：广义—以函数为中心进行编程 和  狭义Haskell—只能通过纯函数进行编程，
2. 引用透明性和副作用
3. 纯函数与局部可变性
4. 模拟高阶类型和Typeclass
5. Monoid 是一种简单的抽象数据类型。使用fold操作。
6. Monad 通用的函数式抽象数据结构，核心是为高阶类型扩展flatMap操作，再结合pure操作，就能以最小的操作集合创造出其他组合的操作。

###### 3. 异步与并发

1. 同步异步【行为】与阻塞非阻塞【状态】。同步不只是阻塞的，也可能是非阻塞的。
2. 异步非阻塞能够提高效率
3. 多线程不一定优于单线程——线程直接切换的开销不容忽视。当线程池中的线程有许多被阻塞住了，CPU就将将线程挂起，去执行别的线程。
4. 协程可以看做是一个轻量级的线程，挂起、切换等。协程的切换可以由程序去控制，不需要OS去调用。
5. launch与runBlocking 主协程,
6. async将协程异步化 和 await
7. 并发线程安全问题
8. Actor 无锁并发，结合Akka
9. CQRS架构，与通常的CRUD架构比较
10. kotlin with PersistentActor

#### 3 实践

###### 1. Android架构

1. 对比MVC、MVP等设计模式
2. MVVM 问题： 需要更多精力定位bug，通用的view需要更好的设计
3. Redux单向数据流
4. ReKotlin 

###### 2. 响应式web应用



